# -*- coding: utf-8 -*-
"""ModelUI.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UPubozixrLe-9CJ9BapWDHt2N3TpiBp0
"""

# Install required libraries (optional, as they're pre-installed in Colab)
!pip install torch torchvision pillow

# Import libraries
import torch
import torchvision.transforms as transforms
from PIL import Image
import json
import torchvision.models as models
import torch.nn as nn
from google.colab import files
import os

# Configuration
DEVICE = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
print(f"Using device: {DEVICE}")

# Disease labels
DISEASE_LABELS = [
    'Atelectasis', 'Consolidation', 'Infiltration', 'Pneumothorax',
    'Edema', 'Emphysema', 'Fibrosis', 'Effusion', 'Pneumonia',
    'Pleural_thickening', 'Cardiomegaly', 'Nodule', 'Mass', 'Hernia'
]

# Define model architecture
class ChestXrayModel(nn.Module):
    def __init__(self, num_classes=14, pretrained=True, dropout=0.3):
        super(ChestXrayModel, self).__init__()
        # Fix the deprecation warning
        if pretrained:
            self.densenet = models.densenet121(weights=models.DenseNet121_Weights.IMAGENET1K_V1)
        else:
            self.densenet = models.densenet121(weights=None)

        num_features = self.densenet.classifier.in_features
        self.densenet.classifier = nn.Sequential(
            nn.BatchNorm1d(num_features),
            nn.Dropout(p=dropout),
            nn.Linear(num_features, 512),
            nn.ReLU(),
            nn.BatchNorm1d(512),
            nn.Dropout(p=dropout),
            nn.Linear(512, num_classes)
        )

    def forward(self, x):
        return self.densenet(x)

# Upload files
print("ðŸ“ Upload your best_model.pth file:")
uploaded_model = files.upload()
MODEL_PATH = list(uploaded_model.keys())[0]

# Check the file
print(f"\nðŸ” Checking uploaded model file...")
print(f"File name: {MODEL_PATH}")
print(f"File size: {os.path.getsize(MODEL_PATH) / (1024*1024):.2f} MB")

# Check if file is valid by reading first few bytes
with open(MODEL_PATH, 'rb') as f:
    header = f.read(100)
    print(f"File header (first 20 bytes): {header[:20]}")

print("\nðŸ“ Upload your Example_image.jpeg file:")
uploaded_image = files.upload()
image_path = list(uploaded_image.keys())[0]

# Load model
print("\nðŸ”„ Loading model...")
model = ChestXrayModel(num_classes=len(DISEASE_LABELS))

try:
    # Try loading with weights_only=False
    checkpoint = torch.load(MODEL_PATH, map_location=DEVICE, weights_only=False)
    print("âœ… Model checkpoint loaded successfully!")

    # Check checkpoint structure
    print(f"Checkpoint keys: {checkpoint.keys()}")

    model.load_state_dict(checkpoint['model_state_dict'])
    model.to(DEVICE)
    model.eval()
    print("âœ… Model loaded and ready!")

except Exception as e:
    print(f"âŒ Error loading model: {str(e)}")
    print("\nâš ï¸ Trying alternative loading methods...")

    try:
        # Try loading as just the state dict (no wrapper)
        checkpoint = torch.load(MODEL_PATH, map_location=DEVICE, weights_only=False)
        model.load_state_dict(checkpoint)
        model.to(DEVICE)
        model.eval()
        print("âœ… Model loaded successfully (direct state dict)!")
    except Exception as e2:
        print(f"âŒ Alternative method also failed: {str(e2)}")
        print("\nðŸš¨ Your model file appears to be corrupted or in an unexpected format.")
        print("Please check:")
        print("1. Did the file upload completely?")
        print("2. Is it a valid PyTorch .pth file?")
        print("3. Try re-uploading the file")
        raise

# Image preprocessing
val_transform = transforms.Compose([
    transforms.Resize((224, 224)),
    transforms.ToTensor(),
    transforms.Normalize(mean=[0.485, 0.456, 0.406],
                         std=[0.229, 0.224, 0.225])
])

# Prediction function
def predict_image(image_path, threshold=0.5):
    image = Image.open(image_path).convert('RGB')
    image_tensor = val_transform(image).unsqueeze(0).to(DEVICE)

    with torch.no_grad():
        outputs = model(image_tensor)
        probs = torch.sigmoid(outputs).cpu().numpy()[0]

    results = []
    for label, prob in zip(DISEASE_LABELS, probs):
        results.append({
            "disease": label,
            "predicted": bool(prob > threshold),
            "probability": float(prob)
        })
    return results

# Make prediction
print("\nðŸ” Making prediction...")
predictions = predict_image(image_path, threshold=0.5)

# Display full results
print("\n" + "="*60)
print("FULL PREDICTION RESULTS")
print("="*60)
print(json.dumps(predictions, indent=2))

# Display detected diseases
print("\n" + "="*60)
print("DETECTED DISEASES (Probability > 50%)")
print("="*60)
detected = [p for p in predictions if p['predicted']]
if detected:
    for p in detected:
        print(f"âœ“ {p['disease']}: {p['probability']*100:.2f}%")
else:
    print("No diseases detected above threshold.")

# Display all probabilities sorted
print("\n" + "="*60)
print("ALL DISEASES (Sorted by Probability)")
print("="*60)
sorted_predictions = sorted(predictions, key=lambda x: x['probability'], reverse=True)
for p in sorted_predictions:
    status = "âœ“" if p['predicted'] else "âœ—"
    print(f"{status} {p['disease']:<20} : {p['probability']*100:6.2f}%")

# Display the image
print("\n" + "="*60)
print("INPUT IMAGE")
print("="*60)
from IPython.display import display
display(Image.open(image_path))

